# -*- coding: utf-8 -*-
"""Python_DS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b3owFko7cWyp_U6VG5ufE-1WUoZROUyc
"""

import pandas as pd
df = pd.read_csv("salaries_by_college_major.csv")

"""df is dataframe created with the dataset. head() function will give top 5 rows of the dataset"""

df.head()

"""To see the number of rows and column in the dataset, we will use shape attribute, it is not function. Here we got 51 rows and 6 columns.
We can also use column atribute for getting the column names
"""

df.shape

df.columns

"""# Missing data and Junk

Checking NaN (Not A Number) values in our dataframe. NAN values are blank cells or cells that contain strings instead of numbers. we can use the .isna() method to spot the values
"""

df.isna()

"""tail() method is used to fetch the bottom 5 rows of the record"""

df.tail()

"""dropna() method is used to remove the rows which have nan value"""

clean_df = df.dropna()
clean_df.tail()

"""# Accessing Columns and Individual Cells in a Dataframe

To access a particular column from a data frame we can use the square bracket notation
"""

clean_df['Starting Median Salary']

clean_df['Starting Median Salary'].max()

clean_df['Starting Median Salary'].idxmax()

clean_df['Starting Median Salary'][43]

clean_df.loc[43]

"""#Challenge 1

What college major has the highest mid-career salary? How much do graduates with this major earn? (Mid-career is defined as having 10+ years of experience).

Ans- College Major = Chemical Engineering, and salary = 107000.0
"""

clean_df['Mid-Career Median Salary'].max()

clean_df['Mid-Career Median Salary'].idxmax()

clean_df.loc[8]

"""#Challenge 2

Which college major has the lowest starting salary and how much do graduates earn after university?

Ans = Major: Spanish and Salary = 34000.0
"""

clean_df['Starting Median Salary'].idxmin()

clean_df.loc[49]

"""#Challenge 3

Which college major has the lowest mid-career salary and how much can people expect to earn with this degree?

Ans: College Major : Education
 and Salary = 52000.0

"""

clean_df['Mid-Career Median Salary'].idxmin()

clean_df.loc[18]

"""#Sorting Values & Adding Columns
Pandas allows us to do simple arithmetic with entire columns, so all we need to do is take the difference between the two columns

Alternatively, we can also use the .subtract() method.

The output of this computation will be another Pandas dataframe column.
"""

clean_df['Mid-Career 90th Percentile Salary'] - clean_df['Mid-Career 10th Percentile Salary']
clean_df['Mid-Career 90th Percentile Salary'].subtract(clean_df['Mid-Career 10th Percentile Salary'])
diff_col = clean_df['Mid-Career 90th Percentile Salary'].subtract(clean_df['Mid-Career 10th Percentile Salary'])
print(diff_col)

"""We can insert this output in the original dataset using .insert()
clean_df.insert(column_no, 'Name_of_Column', 'name_of dataframe_to_insert)
"""

clean_df.insert(1, 'Spread', diff_col)
clean_df.head()

"""#Sorting the values

You can sort the dataframe using .sort_values()

DataFrame.sort_values(by, *, axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last', ignore_index=False, key=None)
"""

low_risk = clean_df.sort_values('Spread')
low_risk[['Undergraduate Major','Spread']].head()

"""#Challenge

Using the .sort_values() method, can you find the degrees with the highest potential? Find the top 5 degrees with the highest values in the 90th percentile.

Also, find the degrees with the greatest spread in salaries. Which majors have the largest difference between high and low earners after graduation.
"""

high_potential = clean_df.sort_values('Mid-Career 90th Percentile Salary')
high_potential['Undergraduate Major'].tail()

great_spread = clean_df.sort_values('Spread',ascending=False)
great_spread[['Undergraduate Major','Spread']].head()

"""#Grouping and Pivoting Data with Pandas

.groupby method can be used
We have three categories in the 'Group' column: STEM, HASS and Business. Let's count how many majors we have in each category
"""

clean_df.groupby('Group').count()

clean_df.groupby('Group').mean(numeric_only=True)